{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\nvar PUNCTUATION_LIST = [\".\", \",\", \"!\", \"?\", \"'\", \"{\", \"}\", \"(\", \")\", \"[\", \"]\", \"/\"];\nvar trimText = function trimText(text) {\n  var min = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 80;\n  var ideal = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 100;\n  var max = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 200;\n\n  //This main function uses two pointers to move out from the ideal, to find the first instance of a punctuation mark followed by a space. If one cannot be found, it will go with the first space closest to the ideal.\n  if (max < min || ideal > max || ideal < min) {\n    throw new Error(\"The minimum length must be less than the maximum, and the ideal must be between the minimum and maximum.\");\n  }\n  if (text.length < ideal) {\n    return [text, ''];\n  }\n  var pointerOne = ideal;\n  var pointerTwo = ideal;\n  var firstSpace, resultIdx;\n  var setSpace = function setSpace(idx) {\n    if (spaceMatch(text[idx])) {\n      firstSpace = firstSpace || idx;\n    }\n  };\n  while (pointerOne < max || pointerTwo > min) {\n    if (checkMatch(pointerOne, text, max, min)) {\n      resultIdx = pointerOne + 1;\n      break;\n    } else if (checkMatch(pointerTwo, text, max, min)) {\n      resultIdx = pointerTwo + 1;\n      break;\n    } else {\n      setSpace(pointerOne);\n      setSpace(pointerTwo);\n    }\n    pointerOne++;\n    pointerTwo--;\n  }\n  if (resultIdx === undefined) {\n    if (firstSpace && firstSpace >= min && firstSpace <= max) {\n      resultIdx = firstSpace;\n    } else if (ideal - min < max - ideal) {\n      resultIdx = min;\n    } else {\n      resultIdx = max;\n    }\n  }\n  return [text.slice(0, resultIdx), text.slice(resultIdx).trim()];\n};\nvar spaceMatch = function spaceMatch(character) {\n  if (character === \" \") {\n    return true;\n  }\n};\nvar punctuationMatch = function punctuationMatch(idx, text) {\n  var punctuationIdx = PUNCTUATION_LIST.indexOf(text[idx]);\n  if (punctuationIdx >= 0 && spaceMatch(text[idx + 1])) {\n    return true;\n  }\n};\nvar checkMatch = function checkMatch(idx, text, max, min) {\n  if (idx < max && idx > min && punctuationMatch(idx, text)) {\n    return true;\n  }\n};\nvar _default = trimText;\nexports[\"default\"] = _default;","map":{"version":3,"names":["Object","defineProperty","exports","value","PUNCTUATION_LIST","trimText","text","min","arguments","length","undefined","ideal","max","Error","pointerOne","pointerTwo","firstSpace","resultIdx","setSpace","idx","spaceMatch","checkMatch","slice","trim","character","punctuationMatch","punctuationIdx","indexOf","_default"],"sources":["C:/Users/madru/OneDrive/Documentos/DevJobs App/devjobs-app/node_modules/read-more-react/dist/utils/trimText.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\nvar PUNCTUATION_LIST = [\".\", \",\", \"!\", \"?\", \"'\", \"{\", \"}\", \"(\", \")\", \"[\", \"]\", \"/\"];\n\nvar trimText = function trimText(text) {\n  var min = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 80;\n  var ideal = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 100;\n  var max = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 200;\n\n  //This main function uses two pointers to move out from the ideal, to find the first instance of a punctuation mark followed by a space. If one cannot be found, it will go with the first space closest to the ideal.\n  if (max < min || ideal > max || ideal < min) {\n    throw new Error(\"The minimum length must be less than the maximum, and the ideal must be between the minimum and maximum.\");\n  }\n\n  if (text.length < ideal) {\n    return [text, ''];\n  }\n\n  var pointerOne = ideal;\n  var pointerTwo = ideal;\n  var firstSpace, resultIdx;\n\n  var setSpace = function setSpace(idx) {\n    if (spaceMatch(text[idx])) {\n      firstSpace = firstSpace || idx;\n    }\n  };\n\n  while (pointerOne < max || pointerTwo > min) {\n    if (checkMatch(pointerOne, text, max, min)) {\n      resultIdx = pointerOne + 1;\n      break;\n    } else if (checkMatch(pointerTwo, text, max, min)) {\n      resultIdx = pointerTwo + 1;\n      break;\n    } else {\n      setSpace(pointerOne);\n      setSpace(pointerTwo);\n    }\n\n    pointerOne++;\n    pointerTwo--;\n  }\n\n  if (resultIdx === undefined) {\n    if (firstSpace && firstSpace >= min && firstSpace <= max) {\n      resultIdx = firstSpace;\n    } else if (ideal - min < max - ideal) {\n      resultIdx = min;\n    } else {\n      resultIdx = max;\n    }\n  }\n\n  return [text.slice(0, resultIdx), text.slice(resultIdx).trim()];\n};\n\nvar spaceMatch = function spaceMatch(character) {\n  if (character === \" \") {\n    return true;\n  }\n};\n\nvar punctuationMatch = function punctuationMatch(idx, text) {\n  var punctuationIdx = PUNCTUATION_LIST.indexOf(text[idx]);\n\n  if (punctuationIdx >= 0 && spaceMatch(text[idx + 1])) {\n    return true;\n  }\n};\n\nvar checkMatch = function checkMatch(idx, text, max, min) {\n  if (idx < max && idx > min && punctuationMatch(idx, text)) {\n    return true;\n  }\n};\n\nvar _default = trimText;\nexports[\"default\"] = _default;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}